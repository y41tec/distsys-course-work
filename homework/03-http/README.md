# HTTP Сервер

Необходимо реализовать простой HTTP сервер, выполняющий функции хранилища
файлов. 

Скорее всего дальнейшем на практике вы будете использовать готовые библиотеки,
в которых уже реализовали работу с семантикой HTTP.
Но стоит хотя бы раз в жизни попробовать это делать "руками", чтобы лучше прочувствовать протокол.

Самую правдивую информацию о формате протокола вы сможете найти в [RFC](https://datatracker.ietf.org/doc/html/rfc2616#section-4).

Настоятельно рекомендуем прочитать всё условие перед тем, как приступать к решению.

## Требуемый функционал

Сервер должен запускаться из командной строки со следующими параметрами:

| Параметр              | Переменная окружения       | Значение по умолчанию | Описание                                                      |
|-----------------------|----------------------------|-----------------------|---------------------------------------------------------------|
| `--host`              | `SERVER_HOST`              | `0.0.0.0`             | Хост, на котором нужно слушать входящие соединения            |
| `--port`              | `SERVER_PORT`              | `8080`                | Порт, на котором нужно слушать входящие соединения            |
| `--working-directory` | `SERVER_WORKING_DIRECTORY` |                       | Абсолютный путь к директории, в которой будут храниться файлы |
| `--server-domain`     | `SERVER_DOMAIN`            |                       | Домен, на котором должен слушать сервер                       |

Если не передан параметр командной строки, то значением параметра будет значение из окружения. Если же значение переменной окружения не указано, нужно использовать значение по умолчанию. 

Если не задан параметр `working-directory`, то нужно сделать `exit(1)`.

### Методы

Вашему серверу будут поступать запросы с указанием `{url}` (Request-URI из RFC),
где под `{url}`
всегда понимается путь к файлу относительно рабочей директории.

#### GET {url}

Возвращает файл, находящийся по пути `{url}`, считая от `working-directory`.

Если путь является директорией, то нужно вывести пользователю таблицу всех
файлов внутри директории в формате вывода `ls -lA` на linux, например:

```
dr-xr-xr-x naorlov naorlov 100 2020-01-01 12:34:00 directory_name
-rwxr--r-- naorlov staff 100 2020-01-01 12:36:00 filename
```

Если клиент выразил желание получить данные в сжатом виде (передал
заголовок `Accept-Encoding`), то данные должны быть сжаты указанным способом
сжатия. Подробнее в секции `Заголовки`.

Если путь отсутствует либо не является валидным путем, необходимо вернуть код
ответа 404 и человеко-читаемый текст в теле ответа.

#### POST {url}

Создает новый файл на сервере по пути `{url}`, считая от `working-directory`.
Данные файла передаются в теле запроса. Если передан
заголовок `Create-Directory: True`, то необходимо создать по указанному пути
директорию.

Если файл уже существует, то необходимо вернуть код ответа 409 и
человеко-читаемый текст в теле ответа.

Если родительской директории по отношению к конечному файлу не существует
(например, пришел запрос `POST /aba/caba/text.py`, но `/aba/caba/` не существует),
вы вправе самостоятельно выбрать, что делать: можно создать промежуточные директории,
а можно не создавать и вернуть ошибку.

#### PUT {url}

Обновляет содержимое файла по пути `{url}`, считая от `working-directory`. Новые
данные файла передаются в теле запроса.

Если файл является директорией, то необходимо вернуть код ответа 409 и
человеко-читаемый текст в теле ответа.

Если файла по заданному пути не существует, можно либо ничего не делать, либо создать его.

#### DELETE {url}

Удаляет файл по пути `{url}`, считая от `working-directory`. Если путь является директорией и в заголовках не указан заголовок `Remove-Directory`, то нужно вернуть ответ 406. При успешном удалении вернуть 200.

## Оценивание

Оценка будет ставиться на основе результатов автоматического тестирования. В процессе тестирования ваше решение будет
много раз запускаться на случайных наборах файлов и директорий, и будет проверяться корректность выполнения сгенерированных
HTTP запросов.

Тесты состоят из нескольких групп. В некоторых группах требуется реализовать только подмножество полного решения, например
в первой группе будет проверяться только работа GET запросов на существующих файлах. Также некоторые группы могут 
накладывать ограничения на содержимое файлов и не требовать обработки некоторых заголовков.

Для получения баллов за каждую группу необходимо чтобы ваше решение успешно прошло все тесты в этой группе.

| Баллы       | Описание группы                                        | (1) GET file  | (2) GET dir | (3) POST, PUT, DELETE | (4) Сжатие | (5) Заголовки | (6) Текстовые файлы | (7) Файлы < 8MB |
|-------------|--------------------------------------------------------|---------------|-------------|-----------------------|------------|---------------|---------------------|-----------------|
| **3 балла** | G1. Только GET запросы к существующим текстовым файлам | + (no errors) | -           | -                     | -          | -             | +                   | +               |
| **1 балл**  | G2. Только GET запросы к существующим файлам           | + (no errors) | -           | -                     | -          | -             | -                   | +               |
| **1 балл**  | G3. Произвольные GET запросы                           | +             | + (simple)  | -                     | -          | -             | +                   | +               |
| **2 балла** | G4. Простой файловый сервер                            | +             | + (simple)  | +                     | -          | -             | -                   | +               |
| **1 балл**  | G5. Проверка домена, обработка MIME типов              | +             | + (simple)  | +                     | -          | +             | -                   | +               |
| **1 балл**  | G6. Подробный листинг директории                       | +             | + (full)    | +                     | -          | -             | -                   | -               |
| **1 балл**  | G7. Поддержка сжатия                                   | +             | + (full)    | +                     | +          | +             | -                   | -               |

При отсутствии solution.md проверка производиться не будет. В нем нужно будет написать используемые библиотеки, если они отличаются от заготовки, а также общее описание архитектуры приложения.

### Ограничения

Далее описываются ограничения на запросы и файлы, с которыми будет взаимодействовать ваш сервер. В таблице для каждой группы указаны ограничения, которые используются для тестирования. Баллы за группу будут начисляться только если ваше решение успешно прошло все тесты в этой группе, то есть только если ваше решение корректно работает на всех возможных запросах удовлетворяющих ограничениям этой группы.
                                                  
#### (1) GET file

`+ (no errors)` – GET запросы только к существующим файлам

`+` – GET запросы по любым путям, в случае отсутствия файла ожидается что сервер вернет ошибку

Учтите, что даже в случае группы G1 вы должны корректно обрабатывать запросы `GET / HTTP/1.1` 
и отправлять корректный HTTP ответ.

#### (2) GET dir

`-` – нет GET запросов к директориям

`+ (simple)` – GET запросы к директориям возвращают список файлов в ней, в любом формате

`+ (full)` – GET запросы к директориям возвращают список файлов в ней, а также размер и дату создания каждого файла


Нужно вывести пользователю таблицу всех
файлов внутри директории, представляющую информацию в следующем формате:
является ли путь директорией, владелец файла, группа файла, размер inode в
байтах, дата, время, название:

```
dr-xr-xr-x naorlov naorlov 100 2020-01-01 12:34:00 directory_name
-rwxr--r-- naorlov staff 100 2020-01-01 12:36:00 filename
```

Подсказка: для получения этой информации необходимо вызвать утилиту `ls` с параметрами `-lA` и `--time-style`. Для локального тестирования на MacOS можно использовать `gls` (не забудьте изменить на `ls` для пайплайна).

#### (3) POST, PUT, DELETE

`-` – нет запросов на изменение файлов

`+` – запросы на изменение файлов (POST, PUT, DELETE)

#### (4) Сжатие

`-` – не проверяется поддержка сжатия

`+` – проверяется поддержка сжатия

При проверке будет передаваться заголовок `Accept-Encoding: gzip`, в ответе ожидается `Content-Encoding: gzip`, в теле ответа должны передаваться данные, сжатые алгоритмом gzip (можно использовать библиотеки).

#### (5) Заголовки

Обмен между клиентом и сервером должен поддерживать следующие заголовки:

| Заголовок          | Допустимые значения  | Использование | Описание                                                                                                                                                                                                      |
|--------------------|----------------------|---------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `Host`             | Любой валидный домен | Клиент        | Клиент отправляет заголовок `Host` с каждым запросом к серверу. В случае, если при запуске сервера был указан параметр `server-domain` не совпадающий с заголовком `Host`, необходимо вернуть код ответа 400. |
| `Content-Length`   | Число                | Сервер        | Число байт в ответе сервера.                                                                                                                                                                                  |
| `Content-Type`     | MIME-тип             | Сервер        | MIME-тип, обозначающий тип передаваемого контента. Для листинга директории можно вернуть `text/plain` или `text/html`, для остальных файлов любой валидный MIME-тип.                                          |
| `Content-Encoding` | `gzip`               | Сервер        | Обозначает, что данные ответа сжаты указанным алгоритмом. Если не указан, то данные ответа не являются сжатыми.                                                                                               |
| `Accept-Encoding`  | `gzip`               | Клиент        | Обозначает, что клиент готов принимать данные, сжатые указанным алгоритмом. Если не указан, данные сжимать не нужно.                                                                                          |
| `Create-Directory` | `True`, `False`      | Клиент        | Если указан И запрос является `POST` запросом, то по указанному пути необходимо создать директорию.                                                                                                           |
| `Server`           | Строка               | Сервер        | Название вашего сервера.                                                                                                                                                                                      |
| `Remove-Directory` | `True`,`False`       | Клиент        | Указание заголовка позволяет системе удалить директорию полностью.                                                                                                                                            |
      
#### (6) Текстовые файлы
      
`+` – все файлы на диске и в запросах являются текстовыми в `ASCII`

`-` – без ограничений на формат файлов, файлы могут содержать случайные байты
                    
#### (7) Файлы < 8MB

`+` – все файлы на диске и в запросах имеют размер не более 8МБ

`-` – без ограничений на размер файлов, файлы могут быть любого размера

**Обратите внимание**, что в CI ваше решение будет запускаться с ограничением на использование оперативной памяти, вашему решению будет доступно 128MB.
Размер файлов может превышать размер доступной оперативной памяти, в этом случае нужно читать и записывать файлы на диск, не загружая их в оперативную память. 
Проверить ваше решение с ограничениями на память можно локально, используя Docker для тестирования (подробнее в разделе *Запуск тестов в CI / Docker*).

### Протокол

1. Является подмножеством протокола HTTP/1.1
2. После отправки ответа от сервера клиенту нужно закрыть соединение

Для простоты будем считать, что сервер не должен уметь обрабатывать несколько соединений одновременно. 
На практике это конечно же не так и обработка соединений происходит в разных потоках.

## Выполнение задания и тестирование

Вам нужно реализовать HTTP сервер без использования готовых библиотек доступных в интернете или в стандартной библиотеке вашего языка. Максимально доступный уровень — TCP сервер, например _socketserver.TCPServer_ в Python.

Код заготовки на питоне приведен в файле `server/server.py`. Вы можете написать решение на основе этого кода, либо использовать любой другой язык, так как для тестов необходим только описанный выше CLI интерфейс (можно даже в докер завернуть, подробнее дальше).

Тесты написаны на Go, для запуска скачайте и установите последнюю версию с сайта https://go.dev/dl/.
Выполнение тестов начинается с функции `TestHW`, которая находится в файле [hw_test.go](./tests/hw_test.go).

Чтобы запустить тесты локально, выполните следующие команды:

```bash
$ cd 3-http
$ cd tests
$ go test
```

Для запуска решения при локальном тестировании используется файл `./launch.sh`. Чтобы запустить сервер, чекер будет запускать данный скрипт и передавать в него аргументы для запуска сервера. Ожидается, что данный скрипт запустит ваше приложение и передаст в него полученные аргументы. Если вы хотите использовать другую версию Python или по другому запускать решение, можно отредактировать этот файл.

### Структура тестов

Тесты имеют иерархическую структуру. Для того чтобы получить оценку 10, решение должно успешно пройти тесты 
во всех группах. Для того чтобы получить оценку за группу, решение должно успешно пройти тесты во всех запусках внутри этой группы.
В каждом запуске сервер запускается один раз на одном наборе файлов и проверяется работа на наборе тестов. Запуск считается успешным,
если сервер правильно обработал все запросы.

Например, `TestHW/G2/93/42300` это уникальный идентификатор одного тестового запроса:
- `G2` – имя группы
- `93` – id запуска; в одном запуске сервер запускается один раз на одном наборе файлов
- `42300` – id одного HTTP запроса

Набор тестов детерминированный, и совпадает при всех выполнениях `go test`. То же самое выполняется для файлов и запросов, их содержимое зависит только от уникального идентификатора.

Если вы хотите запустить тесты только для одного запроса, это можно сделать с использованием фильтров. Например, можно запустить только самый первый запрос в самой первой группе:
```bash
go test -run 'TestHW/G1/1337/96006'
```

Также можно протестировать один конкретный запуск:
```bash
go test -run 'TestHW/G1/1337'
```

Или одну конкретную группу:
```bash
go test -run 'TestHW/G1'
```

### Пример запуска

После запуска тестов на экране появится лог тестирования, с примерно следующим содержимым:

```
INFO    TestHW  Starting tests
INFO    TestHW/G1       Starting tests group    {"points": 3}
INFO    TestHW/G1/42    Running command {"command": "../launch.sh  \"--host=\" \"--port=58771\" \"--working-directory=\"", "env": ["SERVER_HOST=8.8.8.8", "SERVER_PORT=80"]}
INFO:__main__:Starting server on :58771, domain None, working directory 
INFO:__main__:Listening at ('0.0.0.0', 58771)
...
WARN    TestHW/G1/1337  Skipping next queries because of the failed query       {"skipped": 19, "failed": "TestHW/G1/1337/96006"}
WARN    TestHW/G1       Skipping next tests in a group because last test has failed
WARN    TestHW/G1       Tests group failed      {"name": "G1", "score": 0}
INFO    TestHW/G2       Starting tests group    {"points": 1}
...
WARN    TestHW/G2       Tests group failed      {"name": "G2", "score": 0}
...
WARN    TestHW/G7       Tests group failed      {"name": "G7", "score": 0}
INFO    TestHW  Tests finished  {"score": 0}
--- FAIL: TestHW (33.28s)
    ...
    --- FAIL: TestHW/G2 (0.26s)
        --- FAIL: TestHW/G2/93 (0.26s)
            --- FAIL: TestHW/G2/93/42300 (0.00s)
                test_utils.go:36: 
                        Error:          Received unexpected error:
                                        Get "http://localhost:58785/GMR/BWYCPMQHAC/ZVCI": EOF
                        Test:           TestHW/G2/93/42300
                        Messages:       failed to run query on server
    ...


```

Так выглядит лог о начале выполнения тестов для группы, которая стоит 3 балла:
```
INFO    TestHW/G1       Starting tests group    {"points": 3}
```

При запуске решения логируются параметры запуска:
```bash
INFO    TestHW/G1/42    Running command {"command": "../launch.sh  \"--host=\" \"--port=58771\" \"--working-directory=\"", "env": ["SERVER_HOST=8.8.8.8", "SERVER_PORT=80"]}
```

Весь вывод решения в stdout/stderr также виден на экране:
```bash
INFO:__main__:Starting server on :58771, domain None, working directory 
INFO:__main__:Listening at ('0.0.0.0', 58771)
```

При ошибке останавливается тестирование запуска и группы, оценка за группу 0 баллов:
```bash
WARN    TestHW/G1/1337  Skipping next queries because of the failed query       {"skipped": 19, "failed": "TestHW/G1/1337/96006"}
WARN    TestHW/G1       Skipping next tests in a group because last test has failed
WARN    TestHW/G1       Tests group failed      {"name": "G1", "score": 0}
```

В конце тестирования печатается отчет со всеми ошибками и предварительной итоговой оценкой:
```bash
INFO    TestHW  Tests finished  {"score": 0}
```

Обратите внимание, что чекер ожидает поднятия сервера в течение 10 секунд. 
Проверка осуществляется при помощи отправки запросов `GET / HTTP/1.1`, 
сервер должен вернуть любой корректный ответ. 
**Ваше решение должно уметь обрабатывать этот запрос всегда, в рамках любой группы тестов.**

Если в течение 10 секунд ваш сервер не начал отвечать на запросы, вы увидите следующую ошибку:
```
WARN	TestHW/G6/7824	Server didn't get up in time, aborting
ERROR	TestHW/G6/7824	
	Error:      	Received unexpected error:
	            	server did not start in 10 seconds
	Test:       	TestHW/G6/7824
	Messages:   	failed to wait for server
```

### Запуск тестов в CI / Docker

В CI ваше решение будет запускаться не как процесс от такого же пользователя, а как докер контейнер.

Можно попробовать локально протестировать свое решение в таком режиме. Для этого сначала нужно собрать образ своего решения:
```bash
cd server
docker build -t hw3img .
```

После этого для запуска решения нужно поставить переменную окружения `USE_DOCKER`:
```bash
export USE_DOCKER=true
go test
```

### Дополнительно

Более подробные детали можно узнать прочитав исходный код тестов. Для исправлений и улучшений можно прислать pull request.
