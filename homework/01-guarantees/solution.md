# AMO

- в `AtMostOnceSender` будем поддерживать атрибут `_order`, отвечающий количеству отправленных ранее сообщений. Также вместе с каждым сообщением будем передавать его порядковый номер.

- в `AtMostOnceReceiver` будем поддерживать атрибут `_order_store` - множество номеров доставленных ранее сообщений и игнорировать входящее сообщение, если оно было доставлено ранее. Для экономии памяти вооспользуемлся следующим соображением: если после доставки сообщения с номером `N` среди доставленных ранее есть сообщения с номерами `N - MESSAGE_ORDER_LIMIT_AMO`, `N - MESSAGE_ORDER_LIMIT_AMO + 1` ... `N - 1`, то вероятность доставки сообщения с номером меньше `N - MESSAGE_ORDER_LIMIT_AMO` уменьшается с ростом значения `MESSAGE_ORDER_LIMIT_AMO`. Для реализации будем поддерживать атрибут `_order_lower_bound` -- наименьший номер сообщения, который мы готовы принять. Так, если в некоторый момент были доставлены все сообщения с номерами от `N-MESSAGE_ORDER_LIMIT_AMO` до `N`, то `_order_lower_bound` = N + 1`. На практике может сложиться ситуация, в которой первая доставка сообщения будет проигнорирована из-за обновления `_order_lower_bound`, но это означает, что доставка отправленного ранее сообщения заняла больше времени, чем доставка множества сообщений после него, все из которых были получены -- вероятность этого события можно сделать пренебрежимо малой за счет увеличения параметра `MESSAGE_ORDER_LIMIT_AMO`. Компромис данного подхода будет заключаться в том, что недоставленные по этой причине сообщения мы будем считать потеряными во время транспортировки.


# ALO

- в `AtLeastOnceSender` будем поддерживать атрибут `_order`, отвечающий количеству отправленных ранее сообщений. Также вместе с каждым сообщением будем передавать его порядковый номер. Будем запоминать содержимое локальных сообщений в словаре `_message_store`, после чего будем отправлять его и выставлять таймер на время `DELAY_ALO`. По истечении таймера проверим, не пришло ли подтверждение получения сообщения (при получении подтверждение сообщения удаляются из `_message_store`), и если нет, отправим его повторно и снова установим таймер на время `DELAY_ALO` -- это будет продолжаться до тех пор, пока не придет подтверждение получения сообщения. При таком подходе не возникает необходимости оптимизировать ресурсы, чтобы пройти тесты.


- в `AtLeastOnceReceiver` будем отправлять подтверждение доставки сообщения с указанием его порядокового номера.


# EO

- логика `ExactlyOnceSender` почти в точности совпадает с логикой `AtLeastOnceSender`, однако для отпимизации потребления памяти на стороне `ExactlyOnceReceiver` воспользуемся следующим соображением: пусть `ExactlyOnceReceiver` получил все сообщения с номерами от `0` до `N` и не получил сообщение с номером `N + 1`, тогда отправив сообщение с номером `N + K`, `ExactlyOnceReceiver` будет хранить информацию о получении сообщения `N + K` тем дольше, чем больше `K` (см. описание `ExactlyOnceReceiver`). Во избежании таких ситуаций будем сохранять содержимое сообщений и откладывать отправку, если их номера больше `_order_lower_bound + MESSAGE_ORDER_LIMIT_EO` (см. определение _order_lower_bound в описании `ExactlyOnceReceiver`, `MESSAGE_ORDER_LIMIT_EO` - некоторая константа). Компромис данного подхода будет заключаться в том, что не все сообщения отправляются сразу после получения от локального пользователя -- отправка некоторых из них искусственно задерживается для экономии памяти на стороне получателя. 

- в `ExactlyOnceReceiver` будем поддерживать атрибут `_order_store` - множество номеров доставленных ранее сообщений и игнорировать входящее сообщение, если оно было доставлено ранее. Для экономии ресурсов памяти будем поддерживать атрибут `_order_lower_bound` -- наибольший номер сообщения, обладающий свойством: были доставлены все сообщения с номером меньше. Заметим, что в этом случае в `_order_store` достаточно хранить не все доставленные ранее сообщения, а только те, номера которых не меньше `_order_lower_bound`. При получении сообщения будем отправлять подтверждение доставки сообщения с указанием его порядокового номера, а также актуальное значение `_order_lower_bound`.


# EOO

- логика `ExactlyOnceOrderedSender` в точности совпадает с логикой `ExactlyOnceSender`.

- по аналогии с `ExactlyOnceReceiver` в `ExactlyOnceOrderedReceiver` будем поддерживать атрибут `_order_lower_bound`, однако вместо `_order_store` будем поддерживать хранилище сообщений `_message_store`, благодаря чему организуем последовательную отправку сообщений локальному пользователю: если сообщение с номером `_order_lower_bound` присутствует в `_message_store`, отправим его локальному пользователю, обновим `_order_lower_bound` и удалим сообщение из хранилища. При получении сообщения будем отправлять подтверждение доставки сообщения с указанием его порядокового номера, а также актуальное значение `_order_lower_bound`.
