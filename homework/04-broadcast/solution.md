# Описание алгоритма 
### При получении сообщения от пользователя: 
1) произвести best effort broadcast сообщения `message`
2) увеличить счетчик сообщений `_counter`

### При получении сообщения от процесса:
1) добавить отправителя (тут имеется в виду меняющийся при пересылке сообщений отправитель, а не процесс, пользователь которого вызвал `on_local_message`) в множество процессов `_messages_broadcasters[message]`, которые осуществляли best effort broadcast сообщения `message`
2) произвести best effort broadcast сообщения `message`, если  не был проивезедн ранее текущим процессом
3) если сообщение `message` было доставлено пользователю ранее, или best effort broadcast сообщения `message` не был произведен хотя бы половиной всех процессов - закончить выполнение
4) иначе сравнить состояние отправителя `sender_state` (процесс имеет порядковый  номер `j`) в момент отправки сообщения `message` с текущим состоянием `state` (состояние - список, `i`-ый элемент которого содержит номер сообщения, меньше которого были доставлены все сообщения, оправленные `i`-ым процессом): 
    - если текущий процесс доставил сообщения с номерами от `0` до `n-1` (`n` - номер сообщения `message`) процесса `j`, и текущий процесс доставил все сообщения, доставленные процессом `j`, то доставить сообщение `message` и обновлять буфер отложенных сообщений `_messages_buffer` до тех пор, пока есть новые доставленные сообщения
    - иначе добавить сообщение `message` в буфер отложенных сообщений `_messages_buffer`

# Обоснование свойств
1) `No Duplication`: достигается за счет хранения доставленных ранее сообщений в `_messages_deliver`
2) `No Creation`: достигается за счет гарантий транспорта
3) `Validity`: best effort broadcast будет произведен хотя бы половиной всех процессов в силу корректности процесса-отправителя, свойств транспорта и большинства корректных процессов (то есть на пункте 3. выполненение алгоритма получения сообщения от процесса не оставится); все сообщения, отправелнные корректным процессом, будут доставлены самому себе, так как сравнение текущего сосотояния с состоянием на момент отправки сообщений будут приводить к накапливанию до получения предыдущих сообщений самому себе или немедленной доставке сообщений (см пункт 4. алгоритма получения сообщения от процесса)
4) `Uniform Agreement`: достигается за счет соблюдения условий пунктов 3. и 4. алгоритма получения сообщений: если сообщение было доставлено, значит по крайней мере один корректный процесс произвел его best effort broadcast и все сообщения до него от процесса-отправителя были доставлены, значит все корректные процессы доставят это сообщение
5) `Causal Order`: достигается за счет условий пункта 4. алгоритма получения сообщения от процесса (условие доставки совпадает с условием `Causal Order`)

# Возможные оптимизации
В предложенном алгоритме используется следующее соображение: если best effort broadcast сообщения был произведен хотя бы половиной всех процессов, то best effort broadcast сообщения был произведен хотя бы одним корректным процессом. При передаче сообщения можно хранить множество процессов, уже успевших сделать best effort broadcast сообщения, и не производить рассылку при соблюдении условия, тогда количество рассылок на одно сообщение сократится.

Предложенная реализация не использует свойство `Uniform Agreement`. При общении процессы могут дополнительно обмениваться своими состояниями `state` и запрашивать доставленные другими сообщения, которые не были доставлены ими, после чего сохранять их.

Можно также производить best effort broadcast сообщения с вероятностью, уменьшающейся с момента отправки сообщения, это позволит обеспечить масштабируемость рассылки.