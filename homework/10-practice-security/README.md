# Security

## Описание

В рамках данного домашнего задания вам предстоит разработать два http микросервиса — простейший сервис регистрации и авторизации пользователя и простейшее in-memory key-value хранилище с доступами к ключам на основе токенов, выданных сервисом авторизации.

Цель этого задания — познакомиться с базовым способом авторизации пользователей в микросервисных распределенных системах (в данном случае http сервисы).

---

_На каждый хэндлер есть curl-пример в [examples.md](./examples.md)_

### Сервис авторизации

Сервис авторизации выполняет функцию регистрации новых пользователей, авторизации по логину/паролю и проверки существующего токена. Соответственно, сервис имеет три http хэндлера: `/signup`, `/login`, `/whoami`.

#### Регистрация

```
POST /signup
body: { "username": "kek", "password": "kekpassword" }
```
Статусы ответа:
- 200 если всё ок, нас зарегистрировали, в этом случае в заголовке `Set-Cookie` будет указана кука, которую нам надо использовать в дальнейшем.
- 403 если такой пользователь уже существует

#### Авторизация

```
POST /login
body: { "username": "kek", "password": "kekpassword" }
```
Статусы ответа:
- 200 если всё ок, нас зарегистрировали, в этом случае в заголовке `Set-Cookie` будет указана кука, которую нам надо использовать в дальнейшем.
- 403 если пользователя не существует или логин-парль не подошли

#### Проверка пользователя

```
GET /whoami
Cookie: jwt=...
```

Статусы ответа:
- 200 если кука корректная, тогда body будет равен `Hello, {username}`
- 401 если куки нет
- 400 если кука не валидная (мусор или подписана другой подписью)

### Key-value хранилище

Key-value очень простой, он умеет только сохранять строковые ключи и получать строковое значение, с одним ньюансом — пользователь может прочитать и перетереть только свои ключи, при этом перетереть чужие не может, пространство ключей общее на всех.

#### Положить значение

```
POST /put?key=kek
Cookie: jwt=...
body: { "value": "lol" }
```

Статусы ответа:
- 200 если успешно положили или перетерли существующий
- 403 если ключ существует, но его создал другой пользователь
- 401 если куки нет
- 400 если кука не валидная (мусор или подписана другой подписью)

#### Получить значение

```
GET /get?key=kek
Cookie: jwt=...
```

Статусы ответа:
- 200 если ключ есть и это наш ключ, тогда body будет равен `{"value": "lol"}`
- 403 если ключ существует, но не наш
- 404 если ключа не существует
- 401 если куки нет
- 400 если кука не валидная (мусор или подписана другой подписью)

## Требования к реализации

В качестве разновидности токенов предлагается использовать JWT с парой RSA ключей (приватный и публичный). Вам необходимо сгенерировать пару ключей самим с помощью openssl и положить их в папку `auth`: приватный `signature.pem` и публичный `signature.pub` (на самом деле можете положить куда угодно, главное поправьте `docker-compose.yml`).

Хранить сырые пароли в сервисе авторизации нельзя, стандартная практика — хранить хэш пароля (какой-нибудь md5) с какой-то постоянной солью, например в нашем случае именем пользователя.

Писать http сервисы можно на любом языке программирования, главное, чтобы:
- код и Dockerfile auth сервиса находились в папке `auth`
- entrypoint у auth сервиса поддерживал следующие cli аргументы:
  - `--private`: путь до приватного ключа,
  - `--public`: путь до публичного ключа,
  - `--port`: порт, на котором будет запущен http сервер
- код и Dockerfile kv сервиса находились в папке `kv`
- entrypoint у kv сервиса поддерживал следующие cli аргументы:
    - `--public`: путь до публичного ключа,
    - `--port`: порт, на котором будет запущен http сервер

Сейчас в папках auth и kv находится заготовка на языке программирования Go и соответствующие Dockerfile.

## Запуск тестов

Тесты написаны как тесты черных ящиков — тесты делают только http запросы и проверяют, что поведение соответствует ожидаемому. Кроме того, в тесты необходимо передать свою пару ключей.

Чтобы локально запустить тесты, необходимо передать им несколько переменных окружения:

```
сd tests
export JWT_PRIVATE_KEY_FILE=../auth/signature.pem
export JWT_PUBLIC_KEY_FILE=../auth/signature.pub
export AUTH_SERVER_URL="http://localhost:8090"
export KV_SERVER_URL="http://localhost:8091"

pytest -vs [-k <класс с группой тестов>]
```

Чтобы запустить тесты с помощью docker compose достаточно вызвать сборку и запуск одной командой:

```
docker compose up --build tests
```

Запуск в CI происходит именно с помощью docker compose.

## Оценивание

Предварительно оцениваем исходя из пройденных групп тестов:
- **(2 балла)** _TestRSA_ это тесты на валидность пары RSA ключей
- **(4 балла)** _TestAuth_ это тесты на корректность работы auth сервиса
- **(4 балла)** _TestKV_ это тесты на корректность работы kv сервиса

## Рекомендации
- Инструкция по генерированию RSA ключей: https://rietta.com/blog/openssl-generating-rsa-key-from-command/
- JWT библиотека для golang: https://github.com/golang-jwt/jwt
- Для реализации на питоне можно использовать flask, а Dockerfile скопировать из нашего шаблона для задания 02-practice-grpc
- Простейшая JWT библиотека для python: https://pyjwt.readthedocs.io/en/stable/, примеры её использования можно подглядеть у нас в тестах (ну или в документации)
- Вам придется реализовать одинаковую логику проверки jwt токена в хэндлерах kv и в `/whoami`, не рекомендую пытаться сделать этот код общим. Да, некрасиво, но проще скопировать, чем изучать ньюансы работы импорта в вашем языке программирования
