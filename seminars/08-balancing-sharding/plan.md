# План семинара

> Мы не пересказываем содержимое [./readme.md](./readme.md) целиком, за подробностями его можно почитать самим.

## Задача распределения нагрузки и данных

Возможности любого железа ограничены:
- HTTP запросы это CPU и немного памяти
- Хранение данных это объёмы диска
- Чтение и запись данных это сеть, IO, CPU, иногда память

Как в условиях ограниченного железа сделать так, чтобы миллионы пользователей могли пользоваться нашим сервисом?

### Stateless сервисы

Нам не важно кто ответит, тут обычно стоить задача распределения нагрузки в условиях отказов.

- round-robin
- random
- least-connections
- least load average
- P2C
- ...


### Stateful сервисы

Когда нужно управлять состоянием, всё становится несколько сложнее. Наши сервисы не равны, а состояние может быть слишком большим. Или, например, запросы к одному документу могут осуществляться только на одном сервере (можно прикинуть как обрабатывать запросы в Google Docs).

- Шардирование данных по какому-то ключу
- Хэширование и остаток от деления
- Consistent hashing

Иногда для stateless сервисов прибегают к stateful методам, например consistent hashing по IP / username или что-нибудь такое, чтобы сделать балансировку нагрузки более стабильной для одного пользователя, например при наличии кэшей.

## Классическая архитектура для балансировки:

- Load balancer / proxy
- Равные участники кластера, прокси и данные на каждом из них

## Пример round-robin балансировки запросов с помощью nginx

См. [./nginx-balancing](./nginx-balancing/readme.md)

## TODO: Сравнение различных алгоритмов балансировки 

## Простейшее шардирование запросов

См. [./simple-sharding](./simple-sharding/readme.md)

## Пример шардирования данных с помощью самописного прокси

См. [./kv](./kv/readme.md)
